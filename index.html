<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEXUS - Collaborative World Builder</title>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <link href="style_01.css">
</head>
<body>
    <div class="loading" id="loading">Loading...</div>
    
    <div class="header">
        <div class="logo">Nexus World Builder</div>
        <div class="header-actions">
            <input type="text" class="nexus-name" id="nexusName" placeholder="Untitled World" />
            <button class="btn" id="settingsBtn"><span>Settings</span></button>
            <button class="btn btn-primary" id="shareBtn"><span>Share</span></button>
            <button class="btn" id="saveBtn"><span>Save</span></button>
            <button class="btn" id="loadBtn"><span>Load</span></button>
            <button class="btn btn-danger" id="clearBtn"><span>Clear</span></button>
        </div>
    </div>
    
    <div class="main-container">
        <div class="sidebar">
            <div class="sidebar-section">
                <div class="sidebar-title">Search & Filter</div>
                <input type="text" id="searchNodes" placeholder="Search nodes..." style="width: 100%; padding: 0.6rem; background: var(--bg-tertiary); border: 1px solid var(--border); color: var(--text-primary); font-size: 0.875rem; border-radius: 3px; margin-bottom: 0.5rem;" />
                <select id="filterType" style="width: 100%; padding: 0.6rem; background: var(--bg-tertiary); border: 1px solid var(--border); color: var(--text-primary); font-size: 0.875rem; border-radius: 3px; margin-bottom: 0.5rem;">
                    <option value="">All Types</option>
                </select>
                <div id="tagFilters" style="display: flex; flex-wrap: wrap; gap: 0.25rem; margin-top: 0.5rem;"></div>
            </div>
            
            <div class="sidebar-section">
                <div class="sidebar-title">Create Nodes</div>
                <div class="tool-grid" id="nodeTypeButtons">
                    <button class="tool-btn" data-type="character">Character</button>
                    <button class="tool-btn" data-type="location">Location</button>
                    <button class="tool-btn" data-type="item">Item</button>
                    <button class="tool-btn" data-type="event">Event</button>
                    <button class="tool-btn" data-type="faction">Faction</button>
                    <button class="tool-btn" data-type="concept">Concept</button>
                </div>
                <button class="btn" id="addNodeTypeBtn" style="width: 100%; margin-top: 0.5rem;"><span>+ Add Custom Type</span></button>
            </div>
            
            <div class="sidebar-section">
                <div class="sidebar-title">Tools</div>
                <div class="tool-grid">
                    <button class="tool-btn active" id="selectTool">Select</button>
                    <button class="tool-btn" id="linkTool">Link</button>
                </div>
            </div>
            
            <div class="sidebar-section">
                <div class="sidebar-title">View Mode</div>
                <div class="view-modes">
                    <button class="view-mode-btn active" data-view="graph">
                        Graph View
                    </button>
                    <button class="view-mode-btn" data-view="list">
                        List View
                    </button>
                </div>
            </div>
            
            <div class="nodes-list" id="nodesList">
                <div class="sidebar-title">Nodes</div>
            </div>
        </div>
        
        <div class="canvas-container" id="canvasContainer">
            <canvas id="canvas"></canvas>
            <div class="list-view" id="listView">
                <div class="list-view-header">All Nodes</div>
                <div class="list-view-grid" id="listViewGrid"></div>
            </div>
        </div>
    </div>
    
    <div class="modal" id="nodeModal">
        <div class="modal-content" style="max-width: 700px; max-height: 90vh; overflow-y: auto;">
            <div class="modal-title">Create Node</div>
            <div class="form-group">
                <label>Name</label>
                <input type="text" id="nodeName" placeholder="Enter node name" />
            </div>
            <div class="form-group">
                <label>Type</label>
                <select id="nodeType">
                    <option value="character">Character</option>
                    <option value="location">Location</option>
                    <option value="item">Item</option>
                    <option value="event">Event</option>
                    <option value="faction">Faction</option>
                    <option value="concept">Concept</option>
                </select>
            </div>
            <div class="form-group">
                <label>Description</label>
                <textarea id="nodeDescription" placeholder="Describe this node..."></textarea>
            </div>
            <div class="form-group">
                <label>Tags</label>
                <div id="nodeTags" style="display: flex; flex-wrap: wrap; gap: 0.25rem; margin-bottom: 0.5rem;"></div>
                <div style="display: flex; gap: 0.5rem;">
                    <input type="text" id="newTag" placeholder="Add tag..." style="flex: 1; padding: 0.5rem; background: var(--bg-tertiary); border: 1px solid var(--border); color: var(--text-primary); font-size: 0.875rem; border-radius: 3px;" />
                    <button class="btn" id="addTagBtn" style="padding: 0.5rem 1rem;"><span>+</span></button>
                </div>
            </div>
            <div class="form-group">
                <label>Media Attachments</label>
                <div class="media-attachments" id="mediaAttachments"></div>
                <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                    <button class="btn" id="addImageBtn"><span>üì∑ Image</span></button>
                    <button class="btn" id="addAudioBtn"><span>üéµ Audio</span></button>
                    <button class="btn" id="addDrawingBtn"><span>‚úèÔ∏è Drawing</span></button>
                </div>
            </div>
            <div class="form-group">
                <label>Custom Attributes</label>
                <div id="customAttributes"></div>
                <button class="btn" id="addAttributeBtn" style="width: 100%; margin-top: 0.5rem;"><span>+ Add Attribute</span></button>
            </div>
            <div class="form-group">
                <label>Color</label>
                <div class="color-picker-grid" id="colorPicker"></div>
            </div>
            <div class="modal-actions">
                <button class="btn" id="cancelNodeBtn"><span>Cancel</span></button>
                <button class="btn btn-primary" id="createNodeBtn"><span>Create</span></button>
            </div>
        </div>
    </div>
    
    <div class="share-panel" id="sharePanel">
        <div class="modal-title">Share Your Nexus</div>
        <p style="color: var(--text-secondary); margin-bottom: 1rem;">
            Share this URL with others to collaborate in real-time:
        </p>
        <div class="share-url" id="shareUrl"></div>
        <button class="btn btn-primary" id="copyUrlBtn" style="width: 100%;"><span>Copy URL</span></button>
        
        <div class="collaborators">
            <div class="sidebar-title">Active Collaborators</div>
            <div id="collaboratorsList"></div>
        </div>
        
        <button class="btn" id="closeShareBtn" style="width: 100%; margin-top: 1rem;"><span>Close</span></button>
    </div>
    
    <div class="modal" id="settingsModal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-title">Settings</div>
            
            <div style="margin-bottom: 2rem;">
                <div class="sidebar-title">Node Types</div>
                <div id="nodeTypesList" style="margin-bottom: 1rem;"></div>
                <button class="btn btn-primary" id="addCustomNodeType" style="width: 100%;"><span>+ Add Custom Node Type</span></button>
            </div>
            
            <div style="margin-bottom: 2rem;">
                <div class="sidebar-title">Templates</div>
                <p style="color: var(--text-secondary); font-size: 0.875rem; margin-bottom: 1rem;">Save current node as template</p>
                <select id="templateNodeSelect" style="width: 100%; padding: 0.6rem; background: var(--bg-tertiary); border: 1px solid var(--border); color: var(--text-primary); font-size: 0.875rem; border-radius: 3px; margin-bottom: 0.5rem;">
                    <option value="">Select a node...</option>
                </select>
                <button class="btn" id="saveTemplateBtn" style="width: 100%; margin-bottom: 1rem;"><span>Save as Template</span></button>
                <div id="templatesList"></div>
            </div>
            
            <button class="btn" id="closeSettingsBtn" style="width: 100%;"><span>Close</span></button>
        </div>
    </div>
    
    <div class="modal" id="customTypeModal">
        <div class="modal-content">
            <div class="modal-title">Custom Node Type</div>
            <div class="form-group">
                <label>Type Name</label>
                <input type="text" id="customTypeName" placeholder="e.g., Quest, Magic System, Timeline" />
            </div>
            <div class="form-group">
                <label>Default Color</label>
                <div class="color-picker-grid" id="customTypeColorPicker"></div>
            </div>
            <div class="form-group">
                <label>Default Attributes (comma-separated)</label>
                <input type="text" id="customTypeAttributes" placeholder="e.g., Level, HP, Mana" />
            </div>
            <div class="modal-actions">
                <button class="btn" id="cancelCustomTypeBtn"><span>Cancel</span></button>
                <button class="btn btn-primary" id="createCustomTypeBtn"><span>Create</span></button>
            </div>
        </div>
    </div>
    
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" data-action="edit">‚úèÔ∏è Edit Node</div>
        <div class="context-menu-item" data-action="link">üîó Create Link From Here</div>
        <div class="context-menu-item" data-action="duplicate">üìã Duplicate Node</div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item danger" data-action="delete">üóëÔ∏è Delete Node</div>
    </div>
    
    <div class="context-menu" id="linkContextMenu">
        <div class="context-menu-item" data-action="edit-link">‚úèÔ∏è Edit Link</div>
        <div class="context-menu-item danger" data-action="delete-link">üóëÔ∏è Delete Link</div>
    </div>
    
    <div class="modal" id="linkModal">
        <div class="modal-content">
            <div class="modal-title">Edit Connection</div>
            <div class="form-group">
                <label>Label (optional)</label>
                <input type="text" id="linkLabel" placeholder="e.g., 'leads to', 'allies with', 'owns'" />
            </div>
            <div class="form-group">
                <label>Description</label>
                <textarea id="linkDescription" placeholder="Describe this connection..."></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" id="cancelLinkBtn"><span>Cancel</span></button>
                <button class="btn btn-primary" id="saveLinkBtn"><span>Save</span></button>
            </div>
        </div>
    </div>
    
    <div class="modal" id="drawingModal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-title">Create Drawing</div>
            <div class="drawing-canvas-container">
                <div class="drawing-tools">
                    <button class="drawing-tool-btn active" data-tool="pen">Pen</button>
                    <button class="drawing-tool-btn" data-tool="eraser">Eraser</button>
                    <input type="color" id="drawingColor" value="#212121" style="width: 40px; height: 30px; border: 1px solid var(--border); border-radius: 3px; cursor: pointer;" />
                    <input type="range" id="drawingSize" min="1" max="20" value="3" style="width: 100px;" />
                    <button class="btn" id="clearDrawingBtn" style="padding: 0.4rem 0.8rem; margin-left: auto;"><span>Clear</span></button>
                </div>
                <canvas id="drawingCanvas" class="drawing-canvas" width="500" height="400"></canvas>
            </div>
            <div class="modal-actions" style="margin-top: 1rem;">
                <button class="btn" id="cancelDrawingBtn"><span>Cancel</span></button>
                <button class="btn btn-primary" id="saveDrawingBtn"><span>Save Drawing</span></button>
            </div>
        </div>
    </div>
    
    <div class="media-viewer" id="mediaViewer">
        <button class="media-viewer-close" id="closeMediaViewer">√ó</button>
        <div class="media-viewer-content" id="mediaViewerContent"></div>
    </div>
    
    <div class="connection-status" id="connectionStatus">
        <div id="connectionStatusText">Connecting...</div>
        <div id="roomCodeDisplay" style="margin-top: 0.5rem; display: none;">
            Room: <span class="room-code" id="roomCode"></span>
        </div>
    </div>
    
    <script>
        // ==================== STATE MANAGEMENT ====================
        const state = {
            nodes: [],
            links: [],
            selectedNode: null,
            selectedLink: null,
            linkingFrom: null,
            tool: 'select',
            viewMode: 'graph',
            camera: { x: 0, y: 0, zoom: 1 },
            dragging: null,
            panning: false,
            panStart: null,
            collaborators: new Map(),
            myId: Math.random().toString(36).substring(7),
            myColor: `hsl(${Math.random() * 360}, 70%, 60%)`,
            customNodeTypes: [],
            templates: [],
            filters: {
                search: '',
                type: '',
                tags: []
            },
            contextMenuNode: null,
            contextMenuLink: null,
            peer: null,
            connections: new Map(),
            roomCode: null,
            isHost: false
        };
        
        const defaultNodeTypes = [
            { id: 'character', name: 'Character', color: '#2196F3', defaultAttributes: [] },
            { id: 'location', name: 'Location', color: '#4CAF50', defaultAttributes: [] },
            { id: 'item', name: 'Item', color: '#FF9800', defaultAttributes: [] },
            { id: 'event', name: 'Event', color: '#F44336', defaultAttributes: [] },
            { id: 'faction', name: 'Faction', color: '#9C27B0', defaultAttributes: [] },
            { id: 'concept', name: 'Concept', color: '#00BCD4', defaultAttributes: [] }
        ];
        
        const colors = [
            '#2196F3', '#4CAF50', '#FF9800', '#F44336', '#9C27B0',
            '#00BCD4', '#CDDC39', '#FF5722', '#3F51B5', '#E91E63',
            '#009688', '#FFC107'
        ];
        
        // ==================== PEERJS NETWORKING ====================
        let currentEditingMedia = [];
        
        function initializePeer() {
            // Try to get room code from URL
            const urlParams = new URLSearchParams(window.location.search);
            const roomParam = urlParams.get('room');
            
            if (roomParam) {
                // Join existing room
                joinRoom(roomParam);
            } else {
                // Create new room
                createRoom();
            }
        }
        
        function createRoom() {
            state.roomCode = generateRoomCode();
            state.isHost = true;
            
            state.peer = new Peer('nexus-' + state.roomCode, {
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                }
            });
            
            state.peer.on('open', (id) => {
                console.log('Peer initialized with ID:', id);
                updateConnectionStatus('online', `Room created: ${state.roomCode}`);
                updateRoomCodeDisplay();
                
                // Update URL without reload
                const newUrl = window.location.origin + window.location.pathname + '?room=' + state.roomCode;
                window.history.pushState({}, '', newUrl);
            });
            
            state.peer.on('connection', (conn) => {
                handleConnection(conn);
            });
            
            state.peer.on('error', (err) => {
                console.error('Peer error:', err);
                updateConnectionStatus('offline', 'Connection error');
            });
        }
        
        function joinRoom(roomCode) {
            state.roomCode = roomCode;
            state.isHost = false;
            
            state.peer = new Peer({
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ]
                }
            });
            
            state.peer.on('open', (id) => {
                console.log('Peer initialized, joining room:', roomCode);
                const conn = state.peer.connect('nexus-' + roomCode, { reliable: true });
                handleConnection(conn);
                updateRoomCodeDisplay();
            });
            
            state.peer.on('connection', (conn) => {
                handleConnection(conn);
            });
            
            state.peer.on('error', (err) => {
                console.error('Peer error:', err);
                updateConnectionStatus('offline', 'Failed to join room');
            });
        }
        
        function handleConnection(conn) {
            conn.on('open', () => {
                console.log('Connected to peer:', conn.peer);
                state.connections.set(conn.peer, conn);
                
                const peerCount = state.connections.size;
                updateConnectionStatus('online', `Connected (${peerCount + 1} users)`);
                
                // Send current state to new peer
                if (state.isHost) {
                    conn.send({
                        type: 'full_state',
                        data: {
                            nodes: state.nodes,
                            links: state.links,
                            customNodeTypes: state.customNodeTypes,
                            templates: state.templates,
                            name: document.getElementById('nexusName').value
                        }
                    });
                }
            });
            
            conn.on('data', (data) => {
                handlePeerData(data, conn);
            });
            
            conn.on('close', () => {
                console.log('Peer disconnected:', conn.peer);
                state.connections.delete(conn.peer);
                const peerCount = state.connections.size;
                updateConnectionStatus('online', `Connected (${peerCount + 1} users)`);
            });
        }
        
        function handlePeerData(data, conn) {
            if (data.type === 'full_state') {
                // Receiving full state from host
                state.nodes = data.data.nodes;
                state.links = data.data.links;
                state.customNodeTypes = data.data.customNodeTypes || [];
                state.templates = data.data.templates || [];
                document.getElementById('nexusName').value = data.data.name;
                updateNodesList();
                updateListView();
                updateFilterOptions();
                updateNodeTypeButtons();
                render();
            } else if (data.type === 'state_update') {
                // Incremental update
                state.nodes = data.data.nodes;
                state.links = data.data.links;
                state.customNodeTypes = data.data.customNodeTypes || [];
                state.templates = data.data.templates || [];
                document.getElementById('nexusName').value = data.data.name;
                updateNodesList();
                updateListView();
                updateFilterOptions();
                updateNodeTypeButtons();
                render();
            } else if (data.type === 'cursor') {
                updateCollaboratorCursor(data.id, data.color, data.x, data.y);
            }
        }
        
        function broadcastStateToPeers() {
            const data = {
                type: 'state_update',
                data: {
                    nodes: state.nodes,
                    links: state.links,
                    customNodeTypes: state.customNodeTypes,
                    templates: state.templates,
                    name: document.getElementById('nexusName').value
                }
            };
            
            state.connections.forEach((conn) => {
                if (conn.open) {
                    conn.send(data);
                }
            });
        }
        
        function broadcastCursorToPeers(x, y) {
            const data = {
                type: 'cursor',
                id: state.myId,
                color: state.myColor,
                x: x,
                y: y
            };
            
            state.connections.forEach((conn) => {
                if (conn.open) {
                    conn.send(data);
                }
            });
        }
        
        function generateRoomCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }
        
        function updateConnectionStatus(status, message) {
            const statusEl = document.getElementById('connectionStatusText');
            statusEl.className = status === 'online' ? 'connection-status-online' : 'connection-status-offline';
            statusEl.textContent = message;
        }
        
        function updateRoomCodeDisplay() {
            if (state.roomCode) {
                document.getElementById('roomCodeDisplay').style.display = 'block';
                document.getElementById('roomCode').textContent = state.roomCode;
            }
        }
        
        // Helper function to get link at position
        function getLinkAt(x, y) {
            const threshold = 10; // Distance threshold in world coordinates
            
            for (let link of state.links) {
                const fromNode = state.nodes.find(n => n.id === link.from);
                const toNode = state.nodes.find(n => n.id === link.to);
                
                if (!fromNode || !toNode) continue;
                
                // Calculate distance from point to line segment
                const A = x - fromNode.x;
                const B = y - fromNode.y;
                const C = toNode.x - fromNode.x;
                const D = toNode.y - fromNode.y;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                
                if (lenSq !== 0) param = dot / lenSq;
                
                let xx, yy;
                
                if (param < 0) {
                    xx = fromNode.x;
                    yy = fromNode.y;
                } else if (param > 1) {
                    xx = toNode.x;
                    yy = toNode.y;
                } else {
                    xx = fromNode.x + param * C;
                    yy = fromNode.y + param * D;
                }
                
                const dx = x - xx;
                const dy = y - yy;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < threshold) {
                    return link;
                }
            }
            
            return null;
        }
        
        // ==================== CANVAS SETUP ====================
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            render();
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // ==================== RENDERING ====================
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(state.camera.x, state.camera.y);
            ctx.scale(state.camera.zoom, state.camera.zoom);
            
            const filteredNodes = getFilteredNodes();
            const filteredNodeIds = new Set(filteredNodes.map(n => n.id));
            
            // Draw links (only for visible nodes)
            state.links.forEach(link => {
                const fromNode = state.nodes.find(n => n.id === link.from);
                const toNode = state.nodes.find(n => n.id === link.to);
                
                if (fromNode && toNode && filteredNodeIds.has(fromNode.id) && filteredNodeIds.has(toNode.id)) {
                    // Check if this link is selected
                    const isSelected = state.selectedLink && state.selectedLink.id === link.id;
                    
                    ctx.beginPath();
                    ctx.moveTo(fromNode.x, fromNode.y);
                    ctx.lineTo(toNode.x, toNode.y);
                    ctx.strokeStyle = isSelected ? '#F44336' : '#2196F3';
                    ctx.lineWidth = isSelected ? 3 : 2;
                    ctx.stroke();
                    
                    // Arrow
                    const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x);
                    const arrowSize = 8;
                    ctx.save();
                    ctx.translate(toNode.x, toNode.y);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.moveTo(-arrowSize - 40, -arrowSize);
                    ctx.lineTo(-40, 0);
                    ctx.lineTo(-arrowSize - 40, arrowSize);
                    ctx.strokeStyle = isSelected ? '#F44336' : '#2196F3';
                    ctx.lineWidth = isSelected ? 3 : 2;
                    ctx.stroke();
                    ctx.restore();
                    
                    // Draw label if exists
                    if (link.label) {
                        const midX = (fromNode.x + toNode.x) / 2;
                        const midY = (fromNode.y + toNode.y) / 2;
                        
                        // Background
                        ctx.font = '11px Arial';
                        const metrics = ctx.measureText(link.label);
                        const padding = 4;
                        
                        ctx.fillStyle = 'white';
                        ctx.fillRect(
                            midX - metrics.width / 2 - padding,
                            midY - 8 - padding,
                            metrics.width + padding * 2,
                            16 + padding * 2
                        );
                        
                        // Border
                        ctx.strokeStyle = '#e0e0e0';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(
                            midX - metrics.width / 2 - padding,
                            midY - 8 - padding,
                            metrics.width + padding * 2,
                            16 + padding * 2
                        );
                        
                        // Text
                        ctx.fillStyle = '#212121';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(link.label, midX, midY);
                    }
                }
            });
            
            // Draw temp link
            if (state.linkingFrom) {
                const fromNode = state.nodes.find(n => n.id === state.linkingFrom);
                if (fromNode && state.mouseWorld) {
                    ctx.beginPath();
                    ctx.moveTo(fromNode.x, fromNode.y);
                    ctx.lineTo(state.mouseWorld.x, state.mouseWorld.y);
                    ctx.strokeStyle = '#757575';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            // Draw nodes (only filtered ones)
            filteredNodes.forEach(node => {
                const radius = 40;
                
                // Node circle
                ctx.beginPath();
                ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = node.color;
                ctx.fill();
                
                // Border
                ctx.strokeStyle = state.selectedNode === node.id ? '#212121' : '#ffffff';
                ctx.lineWidth = state.selectedNode === node.id ? 3 : 2;
                ctx.stroke();
                
                // Icon (simpler text version)
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.type.charAt(0).toUpperCase(), node.x, node.y);
                
                // Media indicator
                if (node.media && node.media.length > 0) {
                    ctx.beginPath();
                    ctx.arc(node.x + 25, node.y - 25, 8, 0, Math.PI * 2);
                    ctx.fillStyle = '#FF9800';
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 10px Arial';
                    ctx.fillText(node.media.length, node.x + 25, node.y - 25);
                }
                
                // Name
                ctx.fillStyle = '#212121';
                ctx.font = '600 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(node.name, node.x, node.y + radius + 18);
            });
            
            ctx.restore();
        }
        
        // ==================== MOUSE INTERACTION ====================
        let mouse = { x: 0, y: 0 };
        
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
            
            const worldPos = screenToWorld(mouse.x, mouse.y);
            const clickedNode = getNodeAt(worldPos.x, worldPos.y);
            const clickedLink = getLinkAt(worldPos.x, worldPos.y);
            
            if (state.tool === 'select') {
                if (clickedNode) {
                    if (e.shiftKey) {
                        // Edit node
                        editNode(clickedNode);
                    } else {
                        state.dragging = clickedNode.id;
                        state.selectedNode = clickedNode.id;
                        state.selectedLink = null;
                        canvas.style.cursor = 'grabbing';
                    }
                } else if (clickedLink) {
                    // Select link
                    state.selectedLink = clickedLink;
                    state.selectedNode = null;
                    // Double-click to edit
                    if (e.detail === 2) {
                        editLink(clickedLink);
                    }
                } else {
                    state.panning = true;
                    state.panStart = { x: e.clientX - state.camera.x, y: e.clientY - state.camera.y };
                    state.selectedNode = null;
                    state.selectedLink = null;
                    canvas.style.cursor = 'grabbing';
                }
            } else if (state.tool === 'link') {
                if (clickedNode) {
                    if (state.linkingFrom) {
                        // Complete link
                        if (state.linkingFrom !== clickedNode.id) {
                            const newLink = createLink(state.linkingFrom, clickedNode.id);
                            // Ask if they want to add a label
                            setTimeout(() => {
                                if (confirm('Add a label to this connection?')) {
                                    editLink(newLink);
                                }
                            }, 100);
                        }
                        state.linkingFrom = null;
                    } else {
                        // Start link
                        state.linkingFrom = clickedNode.id;
                    }
                }
            }
            
            render();
            broadcastState();
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
            
            const worldPos = screenToWorld(mouse.x, mouse.y);
            state.mouseWorld = worldPos;
            
            if (state.dragging) {
                const node = state.nodes.find(n => n.id === state.dragging);
                if (node) {
                    node.x = worldPos.x;
                    node.y = worldPos.y;
                    render();
                }
            } else if (state.panning) {
                state.camera.x = e.clientX - state.panStart.x;
                state.camera.y = e.clientY - state.panStart.y;
                render();
            } else {
                // Cursor hover effect
                const hoveredNode = getNodeAt(worldPos.x, worldPos.y);
                canvas.style.cursor = hoveredNode ? 'pointer' : 'grab';
            }
            
            // Broadcast cursor position
            broadcastCursor(e.clientX, e.clientY);
            
            if (state.linkingFrom) {
                render();
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            state.dragging = null;
            state.panning = false;
            canvas.style.cursor = 'grab';
            if (state.dragging) {
                broadcastState();
            }
        });
        
        // Right-click context menu
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const worldPos = screenToWorld(mouseX, mouseY);
            
            // Hide all context menus first
            document.getElementById('contextMenu').classList.remove('active');
            document.getElementById('linkContextMenu').classList.remove('active');
            
            // Check if clicked on a node
            const clickedNode = getNodeAt(worldPos.x, worldPos.y);
            if (clickedNode) {
                state.contextMenuNode = clickedNode;
                const menu = document.getElementById('contextMenu');
                menu.style.left = e.clientX + 'px';
                menu.style.top = e.clientY + 'px';
                menu.classList.add('active');
                return;
            }
            
            // Check if clicked on a link
            const clickedLink = getLinkAt(worldPos.x, worldPos.y);
            if (clickedLink) {
                state.contextMenuLink = clickedLink;
                const menu = document.getElementById('linkContextMenu');
                menu.style.left = e.clientX + 'px';
                menu.style.top = e.clientY + 'px';
                menu.classList.add('active');
                return;
            }
        });
        
        // Close context menus on click outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.context-menu')) {
                document.getElementById('contextMenu').classList.remove('active');
                document.getElementById('linkContextMenu').classList.remove('active');
            }
        });
        
        // Handle context menu actions for nodes
        document.querySelectorAll('#contextMenu .context-menu-item').forEach(item => {
            item.addEventListener('click', () => {
                const action = item.dataset.action;
                const node = state.contextMenuNode;
                
                if (!node) return;
                
                switch(action) {
                    case 'edit':
                        editNode(node);
                        break;
                    case 'link':
                        state.tool = 'link';
                        state.linkingFrom = node.id;
                        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                        document.getElementById('linkTool').classList.add('active');
                        render();
                        break;
                    case 'duplicate':
                        const worldCenter = screenToWorld(canvas.width / 2 + 50, canvas.height / 2 + 50);
                        const duplicate = {
                            id: Date.now() + Math.random(),
                            type: node.type,
                            name: node.name + ' (Copy)',
                            description: node.description,
                            color: node.color,
                            tags: [...(node.tags || [])],
                            attributes: {...(node.attributes || {})},
                            x: worldCenter.x,
                            y: worldCenter.y
                        };
                        state.nodes.push(duplicate);
                        updateNodesList();
                        updateListView();
                        updateFilterOptions();
                        render();
                        broadcastState();
                        break;
                    case 'delete':
                        if (confirm(`Delete "${node.name}"?`)) {
                            deleteNode(node.id);
                        }
                        break;
                }
                
                document.getElementById('contextMenu').classList.remove('active');
            });
        });
        
        // Handle context menu actions for links
        document.querySelectorAll('#linkContextMenu .context-menu-item').forEach(item => {
            item.addEventListener('click', () => {
                const action = item.dataset.action;
                const link = state.contextMenuLink;
                
                if (!link) return;
                
                switch(action) {
                    case 'edit-link':
                        editLink(link);
                        break;
                    case 'delete-link':
                        const fromNode = state.nodes.find(n => n.id === link.from);
                        const toNode = state.nodes.find(n => n.id === link.to);
                        const confirmMsg = fromNode && toNode 
                            ? `Delete connection from "${fromNode.name}" to "${toNode.name}"?`
                            : 'Delete this connection?';
                        if (confirm(confirmMsg)) {
                            deleteLink(link);
                        }
                        break;
                }
                
                document.getElementById('linkContextMenu').classList.remove('active');
            });
        });
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const worldBefore = screenToWorld(mouseX, mouseY);
            
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            state.camera.zoom = Math.max(0.1, Math.min(3, state.camera.zoom * zoomFactor));
            
            const worldAfter = screenToWorld(mouseX, mouseY);
            
            state.camera.x += (worldAfter.x - worldBefore.x) * state.camera.zoom;
            state.camera.y += (worldAfter.y - worldBefore.y) * state.camera.zoom;
            
            render();
        });
        
        function screenToWorld(screenX, screenY) {
            return {
                x: (screenX - state.camera.x) / state.camera.zoom,
                y: (screenY - state.camera.y) / state.camera.zoom
            };
        }
        
        function getNodeAt(x, y) {
            return state.nodes.find(node => {
                const dx = node.x - x;
                const dy = node.y - y;
                return Math.sqrt(dx * dx + dy * dy) < 40;
            });
        }
        
        // ==================== NODE MANAGEMENT ====================
        function createNode(type, x, y) {
            const nodeType = getAllNodeTypes().find(t => t.id === type);
            const node = {
                id: Date.now() + Math.random(),
                type: type,
                name: 'New ' + (nodeType ? nodeType.name : type),
                description: '',
                color: nodeType ? nodeType.color : colors[Math.floor(Math.random() * colors.length)],
                x: x || canvas.width / 2,
                y: y || canvas.height / 2,
                tags: [],
                attributes: {},
                media: []  // Array of {type: 'image'|'audio'|'drawing', data: base64}
            };
            
            // Add default attributes from node type
            if (nodeType && nodeType.defaultAttributes) {
                nodeType.defaultAttributes.forEach(attr => {
                    node.attributes[attr] = '';
                });
            }
            
            state.nodes.push(node);
            updateNodesList();
            updateFilterOptions();
            render();
            broadcastState();
            return node;
        }
        
        function getAllNodeTypes() {
            return [...defaultNodeTypes, ...state.customNodeTypes];
        }
        
        function getNodeTypeById(id) {
            return getAllNodeTypes().find(t => t.id === id);
        }
        
        function editNode(node) {
            const modal = document.getElementById('nodeModal');
            const title = modal.querySelector('.modal-title');
            title.textContent = 'Edit Node';
            
            document.getElementById('nodeName').value = node.name;
            document.getElementById('nodeType').value = node.type;
            document.getElementById('nodeDescription').value = node.description || '';
            
            // Set selected color
            document.querySelectorAll('#colorPicker .color-option').forEach(opt => {
                opt.classList.toggle('selected', opt.style.backgroundColor === node.color);
            });
            
            // Render tags
            renderNodeTags(node.tags || []);
            
            // Render custom attributes
            renderCustomAttributes(node.attributes || {});
            
            // Render media
            currentEditingMedia = [...(node.media || [])];
            renderMediaAttachments();
            
            modal.classList.add('active');
            
            const createBtn = document.getElementById('createNodeBtn');
            createBtn.textContent = 'Save';
            
            const handler = () => {
                node.name = document.getElementById('nodeName').value || node.name;
                node.type = document.getElementById('nodeType').value;
                node.description = document.getElementById('nodeDescription').value;
                
                const selectedColor = document.querySelector('#colorPicker .color-option.selected');
                if (selectedColor) {
                    node.color = selectedColor.style.backgroundColor;
                }
                
                // Save tags
                node.tags = currentEditingTags;
                
                // Save attributes
                node.attributes = {};
                document.querySelectorAll('#customAttributes .attribute-row').forEach(row => {
                    const keyInput = row.querySelector('.attr-key');
                    const valueInput = row.querySelector('.attr-value');
                    if (keyInput && valueInput && keyInput.value) {
                        node.attributes[keyInput.value] = valueInput.value;
                    }
                });
                
                // Save media
                node.media = currentEditingMedia;
                
                modal.classList.remove('active');
                updateNodesList();
                updateListView();
                updateFilterOptions();
                render();
                broadcastState();
                
                createBtn.removeEventListener('click', handler);
                createBtn.textContent = 'Create';
            };
            
            createBtn.addEventListener('click', handler);
        }
        
        function renderMediaAttachments() {
            const container = document.getElementById('mediaAttachments');
            container.innerHTML = '';
            
            currentEditingMedia.forEach((media, index) => {
                const item = document.createElement('div');
                item.className = 'media-item';
                
                if (media.type === 'image') {
                    const img = document.createElement('img');
                    img.src = media.data;
                    img.alt = 'Attachment';
                    item.appendChild(img);
                } else if (media.type === 'audio') {
                    item.className = 'media-item media-item-audio';
                    item.textContent = 'üéµ';
                } else if (media.type === 'drawing') {
                    const canvas = document.createElement('canvas');
                    canvas.width = 500;
                    canvas.height = 400;
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    img.onload = () => {
                        ctx.drawImage(img, 0, 0);
                    };
                    img.src = media.data;
                    
                    item.className = 'media-item media-item-drawing';
                    item.appendChild(canvas);
                }
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'media-item-remove';
                removeBtn.textContent = '√ó';
                removeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    currentEditingMedia.splice(index, 1);
                    renderMediaAttachments();
                });
                item.appendChild(removeBtn);
                
                // Click to view full size
                item.addEventListener('click', () => {
                    viewMedia(media);
                });
                
                container.appendChild(item);
            });
        }
        
        function viewMedia(media) {
            const viewer = document.getElementById('mediaViewer');
            const content = document.getElementById('mediaViewerContent');
            content.innerHTML = '';
            
            if (media.type === 'image' || media.type === 'drawing') {
                const img = document.createElement('img');
                img.src = media.data;
                content.appendChild(img);
            } else if (media.type === 'audio') {
                const audio = document.createElement('audio');
                audio.src = media.data;
                audio.controls = true;
                audio.style.maxWidth = '90%';
                content.appendChild(audio);
            }
            
            viewer.classList.add('active');
        }
        
        let currentEditingTags = [];
        
        function renderNodeTags(tags) {
            currentEditingTags = [...tags];
            const container = document.getElementById('nodeTags');
            container.innerHTML = '';
            
            currentEditingTags.forEach(tag => {
                const tagEl = document.createElement('span');
                tagEl.className = 'tag tag-removable';
                tagEl.innerHTML = `${tag} <span class="tag-remove">√ó</span>`;
                tagEl.querySelector('.tag-remove').addEventListener('click', () => {
                    currentEditingTags = currentEditingTags.filter(t => t !== tag);
                    renderNodeTags(currentEditingTags);
                });
                container.appendChild(tagEl);
            });
        }
        
        function renderCustomAttributes(attributes) {
            const container = document.getElementById('customAttributes');
            container.innerHTML = '';
            
            Object.entries(attributes).forEach(([key, value]) => {
                addAttributeRow(key, value);
            });
        }
        
        function addAttributeRow(key = '', value = '') {
            const container = document.getElementById('customAttributes');
            const row = document.createElement('div');
            row.className = 'attribute-row';
            row.innerHTML = `
                <input type="text" class="attr-key" placeholder="Key" value="${key}" />
                <input type="text" class="attr-value" placeholder="Value" value="${value}" />
                <span class="attribute-remove">√ó</span>
            `;
            row.querySelector('.attribute-remove').addEventListener('click', () => {
                row.remove();
            });
            container.appendChild(row);
        }
        
        function createLink(fromId, toId, label = '', description = '') {
            const existing = state.links.find(l => 
                (l.from === fromId && l.to === toId) || (l.from === toId && l.to === fromId)
            );
            
            if (!existing) {
                state.links.push({ 
                    id: Date.now() + Math.random(),
                    from: fromId, 
                    to: toId,
                    label: label,
                    description: description
                });
                render();
                broadcastState();
                return state.links[state.links.length - 1];
            }
            return existing;
        }
        
        function editLink(link) {
            const modal = document.getElementById('linkModal');
            document.getElementById('linkLabel').value = link.label || '';
            document.getElementById('linkDescription').value = link.description || '';
            
            modal.classList.add('active');
            
            const saveHandler = () => {
                link.label = document.getElementById('linkLabel').value;
                link.description = document.getElementById('linkDescription').value;
                modal.classList.remove('active');
                render();
                broadcastState();
                document.getElementById('saveLinkBtn').removeEventListener('click', saveHandler);
            };
            
            document.getElementById('saveLinkBtn').addEventListener('click', saveHandler);
        }
        
        function deleteLink(link) {
            state.links = state.links.filter(l => l.id !== link.id);
            render();
            broadcastState();
        }
        
        function deleteNode(nodeId) {
            state.nodes = state.nodes.filter(n => n.id !== nodeId);
            state.links = state.links.filter(l => l.from !== nodeId && l.to !== nodeId);
            if (state.selectedNode === nodeId) {
                state.selectedNode = null;
            }
            updateNodesList();
            updateListView();
            updateFilterOptions();
            render();
            broadcastState();
        }
        
        // ==================== FILTERING ====================
        function getFilteredNodes() {
            return state.nodes.filter(node => {
                // Search filter
                if (state.filters.search) {
                    const searchLower = state.filters.search.toLowerCase();
                    const matchName = node.name.toLowerCase().includes(searchLower);
                    const matchDesc = (node.description || '').toLowerCase().includes(searchLower);
                    const matchType = node.type.toLowerCase().includes(searchLower);
                    const matchTags = (node.tags || []).some(tag => tag.toLowerCase().includes(searchLower));
                    const matchAttrs = Object.entries(node.attributes || {}).some(([k, v]) => 
                        k.toLowerCase().includes(searchLower) || v.toLowerCase().includes(searchLower)
                    );
                    
                    if (!matchName && !matchDesc && !matchType && !matchTags && !matchAttrs) {
                        return false;
                    }
                }
                
                // Type filter
                if (state.filters.type && node.type !== state.filters.type) {
                    return false;
                }
                
                // Tag filters
                if (state.filters.tags.length > 0) {
                    const nodeTags = node.tags || [];
                    const hasAllTags = state.filters.tags.every(tag => nodeTags.includes(tag));
                    if (!hasAllTags) {
                        return false;
                    }
                }
                
                return true;
            });
        }
        
        function updateFilterOptions() {
            // Update type filter dropdown
            const typeFilter = document.getElementById('filterType');
            const currentValue = typeFilter.value;
            typeFilter.innerHTML = '<option value="">All Types</option>';
            
            getAllNodeTypes().forEach(type => {
                const option = document.createElement('option');
                option.value = type.id;
                option.textContent = type.name;
                typeFilter.appendChild(option);
            });
            typeFilter.value = currentValue;
            
            // Update tag filters
            const allTags = new Set();
            state.nodes.forEach(node => {
                (node.tags || []).forEach(tag => allTags.add(tag));
            });
            
            const tagFilters = document.getElementById('tagFilters');
            tagFilters.innerHTML = '';
            
            allTags.forEach(tag => {
                const tagEl = document.createElement('span');
                tagEl.className = 'tag tag-filter';
                if (state.filters.tags.includes(tag)) {
                    tagEl.classList.add('active');
                }
                tagEl.textContent = tag;
                tagEl.addEventListener('click', () => {
                    if (state.filters.tags.includes(tag)) {
                        state.filters.tags = state.filters.tags.filter(t => t !== tag);
                    } else {
                        state.filters.tags.push(tag);
                    }
                    updateFilterOptions();
                    updateNodesList();
                    updateListView();
                    render();
                });
                tagFilters.appendChild(tagEl);
            });
        }
        
        // ==================== UI INTERACTIONS ====================
        
        // Search and filters
        document.getElementById('searchNodes').addEventListener('input', (e) => {
            state.filters.search = e.target.value;
            updateNodesList();
            updateListView();
            render();
        });
        
        document.getElementById('filterType').addEventListener('change', (e) => {
            state.filters.type = e.target.value;
            updateNodesList();
            updateListView();
            render();
        });
        
        // Add tag in node modal
        document.getElementById('addTagBtn').addEventListener('click', () => {
            const input = document.getElementById('newTag');
            const tag = input.value.trim();
            if (tag && !currentEditingTags.includes(tag)) {
                currentEditingTags.push(tag);
                renderNodeTags(currentEditingTags);
                input.value = '';
            }
        });
        
        document.getElementById('newTag').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('addTagBtn').click();
            }
        });
        
        // Add attribute in node modal
        document.getElementById('addAttributeBtn').addEventListener('click', () => {
            addAttributeRow();
        });
        
        // Media upload handlers
        document.getElementById('addImageBtn').addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        currentEditingMedia.push({
                            type: 'image',
                            data: event.target.result
                        });
                        renderMediaAttachments();
                    };
                    reader.readAsDataURL(file);
                }
            });
            input.click();
        });
        
        document.getElementById('addAudioBtn').addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'audio/*';
            input.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        currentEditingMedia.push({
                            type: 'audio',
                            data: event.target.result
                        });
                        renderMediaAttachments();
                    };
                    reader.readAsDataURL(file);
                }
            });
            input.click();
        });
        
        document.getElementById('addDrawingBtn').addEventListener('click', () => {
            openDrawingCanvas();
        });
        
        // Media viewer close
        document.getElementById('closeMediaViewer').addEventListener('click', () => {
            document.getElementById('mediaViewer').classList.remove('active');
        });
        
        // Drawing canvas
        let drawingCtx = null;
        let isDrawing = false;
        let drawingTool = 'pen';
        let drawingColor = '#212121';
        let drawingSize = 3;
        
        function openDrawingCanvas() {
            const modal = document.getElementById('drawingModal');
            const canvas = document.getElementById('drawingCanvas');
            drawingCtx = canvas.getContext('2d');
            
            // Clear canvas
            drawingCtx.fillStyle = 'white';
            drawingCtx.fillRect(0, 0, canvas.width, canvas.height);
            
            modal.classList.add('active');
        }
        
        document.querySelectorAll('.drawing-tool-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.drawing-tool-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                drawingTool = btn.dataset.tool;
            });
        });
        
        document.getElementById('drawingColor').addEventListener('change', (e) => {
            drawingColor = e.target.value;
        });
        
        document.getElementById('drawingSize').addEventListener('input', (e) => {
            drawingSize = parseInt(e.target.value);
        });
        
        document.getElementById('clearDrawingBtn').addEventListener('click', () => {
            const canvas = document.getElementById('drawingCanvas');
            drawingCtx.fillStyle = 'white';
            drawingCtx.fillRect(0, 0, canvas.width, canvas.height);
        });
        
        const drawingCanvas = document.getElementById('drawingCanvas');
        
        drawingCanvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const rect = drawingCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            drawingCtx.beginPath();
            drawingCtx.moveTo(x, y);
        });
        
        drawingCanvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            
            const rect = drawingCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (drawingTool === 'pen') {
                drawingCtx.strokeStyle = drawingColor;
                drawingCtx.lineWidth = drawingSize;
            } else if (drawingTool === 'eraser') {
                drawingCtx.strokeStyle = 'white';
                drawingCtx.lineWidth = drawingSize * 3;
            }
            
            drawingCtx.lineCap = 'round';
            drawingCtx.lineJoin = 'round';
            drawingCtx.lineTo(x, y);
            drawingCtx.stroke();
        });
        
        drawingCanvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });
        
        drawingCanvas.addEventListener('mouseleave', () => {
            isDrawing = false;
        });
        
        document.getElementById('cancelDrawingBtn').addEventListener('click', () => {
            document.getElementById('drawingModal').classList.remove('active');
        });
        
        document.getElementById('saveDrawingBtn').addEventListener('click', () => {
            const canvas = document.getElementById('drawingCanvas');
            const dataUrl = canvas.toDataURL('image/png');
            
            currentEditingMedia.push({
                type: 'drawing',
                data: dataUrl
            });
            renderMediaAttachments();
            
            document.getElementById('drawingModal').classList.remove('active');
        });
        
        // Dynamic node type buttons
        function updateNodeTypeButtons() {
            const container = document.getElementById('nodeTypeButtons');
            container.innerHTML = '';
            
            getAllNodeTypes().forEach(type => {
                const btn = document.createElement('button');
                btn.className = 'tool-btn';
                btn.dataset.type = type.id;
                btn.textContent = type.name;
                btn.addEventListener('click', () => {
                    const worldCenter = screenToWorld(canvas.width / 2, canvas.height / 2);
                    const node = createNode(type.id, worldCenter.x, worldCenter.y);
                    editNode(node);
                });
                container.appendChild(btn);
            });
            
            // Update node type dropdown in modal
            const select = document.getElementById('nodeType');
            select.innerHTML = '';
            getAllNodeTypes().forEach(type => {
                const option = document.createElement('option');
                option.value = type.id;
                option.textContent = type.name;
                select.appendChild(option);
            });
        }
        
        // Tool buttons (kept from original)
        document.querySelectorAll('.tool-btn[data-type]').forEach(btn => {
            btn.addEventListener('click', () => {
                const type = btn.dataset.type;
                const worldCenter = screenToWorld(canvas.width / 2, canvas.height / 2);
                const node = createNode(type, worldCenter.x, worldCenter.y);
                editNode(node);
            });
        });
        
        // Tool selection
        document.getElementById('selectTool').addEventListener('click', () => {
            state.tool = 'select';
            state.linkingFrom = null;
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('selectTool').classList.add('active');
            render();
        });
        
        document.getElementById('linkTool').addEventListener('click', () => {
            state.tool = 'link';
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('linkTool').classList.add('active');
        });
        
        // View mode switching
        document.querySelectorAll('.view-mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const view = btn.dataset.view;
                state.viewMode = view;
                
                document.querySelectorAll('.view-mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                if (view === 'graph') {
                    document.getElementById('canvas').style.display = 'block';
                    document.getElementById('listView').classList.remove('active');
                } else if (view === 'list') {
                    document.getElementById('canvas').style.display = 'none';
                    document.getElementById('listView').classList.add('active');
                    updateListView();
                }
            });
        });
        
        // Modal
        const modal = document.getElementById('nodeModal');
        const colorPicker = document.getElementById('colorPicker');
        const customTypeColorPicker = document.getElementById('customTypeColorPicker');
        
        // Initialize both color pickers
        [colorPicker, customTypeColorPicker].forEach(picker => {
            colors.forEach(color => {
                const opt = document.createElement('div');
                opt.className = 'color-option';
                opt.style.backgroundColor = color;
                opt.addEventListener('click', () => {
                    picker.querySelectorAll('.color-option').forEach(o => o.classList.remove('selected'));
                    opt.classList.add('selected');
                });
                picker.appendChild(opt);
            });
        });
        
        document.getElementById('cancelNodeBtn').addEventListener('click', () => {
            modal.classList.remove('active');
        });
        
        document.getElementById('createNodeBtn').addEventListener('click', () => {
            // This is handled by editNode for editing
            // For new nodes, this won't be called as editNode overrides it
        });
        
        document.getElementById('cancelLinkBtn').addEventListener('click', () => {
            document.getElementById('linkModal').classList.remove('active');
        });
        
        // Nodes list
        function updateNodesList() {
            const list = document.getElementById('nodesList');
            const title = list.querySelector('.sidebar-title');
            list.innerHTML = '';
            list.appendChild(title);
            
            const filteredNodes = getFilteredNodes();
            
            filteredNodes.forEach(node => {
                const item = document.createElement('div');
                item.className = 'node-item';
                
                const tagsHtml = (node.tags || []).length > 0 
                    ? `<div style="font-size: 0.65rem; color: var(--accent-primary); margin-top: 0.25rem;">${(node.tags || []).join(', ')}</div>`
                    : '';
                
                item.innerHTML = `
                    <div>
                        <div style="font-weight: 600;">${node.name}</div>
                        <div class="node-item-type">${node.type}</div>
                        ${tagsHtml}
                    </div>
                    <span class="node-item-delete">√ó</span>
                `;
                
                item.addEventListener('click', (e) => {
                    if (e.target.classList.contains('node-item-delete')) {
                        deleteNode(node.id);
                    } else {
                        state.selectedNode = node.id;
                        
                        // Pan to node
                        state.camera.x = canvas.width / 2 - node.x * state.camera.zoom;
                        state.camera.y = canvas.height / 2 - node.y * state.camera.zoom;
                        
                        render();
                    }
                });
                
                list.appendChild(item);
            });
        }
        
        // List view
        function updateListView() {
            const grid = document.getElementById('listViewGrid');
            grid.innerHTML = '';
            
            const filteredNodes = getFilteredNodes();
            
            filteredNodes.forEach(node => {
                const connections = state.links.filter(l => l.from === node.id || l.to === node.id);
                
                const tagsHtml = (node.tags || []).length > 0
                    ? `<div style="margin-top: 0.5rem;">${(node.tags || []).map(tag => 
                        `<span class="tag" style="margin-right: 0.25rem;">${tag}</span>`
                    ).join('')}</div>`
                    : '';
                
                const attrsHtml = Object.keys(node.attributes || {}).length > 0
                    ? `<div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--text-secondary);">${
                        Object.entries(node.attributes || {}).map(([k, v]) => 
                            `<div><strong>${k}:</strong> ${v || '(empty)'}</div>`
                        ).join('')
                    }</div>`
                    : '';
                
                // Build connections display
                let connectionsHtml = `<div class="list-card-connections" style="margin-top: 0.75rem;">${connections.length} connections</div>`;
                if (connections.length > 0) {
                    connectionsHtml += '<div style="font-size: 0.7rem; color: var(--text-secondary); margin-top: 0.25rem;">';
                    connections.slice(0, 3).forEach(link => {
                        const otherNodeId = link.from === node.id ? link.to : link.from;
                        const otherNode = state.nodes.find(n => n.id === otherNodeId);
                        if (otherNode) {
                            const direction = link.from === node.id ? '‚Üí' : '‚Üê';
                            const labelText = link.label ? ` (${link.label})` : '';
                            connectionsHtml += `<div>${direction} ${otherNode.name}${labelText}</div>`;
                        }
                    });
                    if (connections.length > 3) {
                        connectionsHtml += `<div>... and ${connections.length - 3} more</div>`;
                    }
                    connectionsHtml += '</div>';
                }
                
                const card = document.createElement('div');
                card.className = 'list-card';
                card.innerHTML = `
                    <div class="list-card-header">
                        <div>
                            <div class="list-card-title">${node.name}</div>
                            <div class="list-card-type">${node.type}</div>
                        </div>
                        <div class="list-card-color" style="background: ${node.color};"></div>
                    </div>
                    <div class="list-card-description">${node.description || 'No description'}</div>
                    ${tagsHtml}
                    ${attrsHtml}
                    ${connectionsHtml}
                `;
                
                card.addEventListener('click', () => {
                    state.selectedNode = node.id;
                    state.viewMode = 'graph';
                    
                    // Switch to graph view
                    document.querySelector('[data-view="graph"]').click();
                    
                    // Pan to node
                    state.camera.x = canvas.width / 2 - node.x * state.camera.zoom;
                    state.camera.y = canvas.height / 2 - node.y * state.camera.zoom;
                    
                    render();
                });
                
                grid.appendChild(card);
            });
        }
        
        // Save/Load
        document.getElementById('saveBtn').addEventListener('click', () => {
            const nexusName = document.getElementById('nexusName').value || 'untitled';
            const data = {
                name: nexusName,
                nodes: state.nodes,
                links: state.links,
                customNodeTypes: state.customNodeTypes,
                templates: state.templates
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${nexusName.replace(/\s+/g, '-')}.nexus.json`;
            a.click();
            URL.revokeObjectURL(url);
        });
        
        document.getElementById('loadBtn').addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            document.getElementById('nexusName').value = data.name || 'Untitled World';
                            state.nodes = data.nodes || [];
                            state.links = data.links || [];
                            state.customNodeTypes = data.customNodeTypes || [];
                            state.templates = data.templates || [];
                            updateNodesList();
                            updateListView();
                            updateFilterOptions();
                            updateNodeTypeButtons();
                            render();
                            broadcastState();
                        } catch (err) {
                            alert('Error loading file: ' + err.message);
                        }
                    };
                    reader.readAsText(file);
                }
            });
            input.click();
        });
        
        // Settings modal
        document.getElementById('settingsBtn').addEventListener('click', () => {
            const modal = document.getElementById('settingsModal');
            modal.classList.add('active');
            updateNodeTypesList();
            updateTemplatesList();
            updateTemplateNodeSelect();
        });
        
        document.getElementById('closeSettingsBtn').addEventListener('click', () => {
            document.getElementById('settingsModal').classList.remove('active');
        });
        
        // Custom node type modal
        document.getElementById('addNodeTypeBtn').addEventListener('click', () => {
            showCustomTypeModal();
        });
        
        document.getElementById('addCustomNodeType').addEventListener('click', () => {
            showCustomTypeModal();
        });
        
        function showCustomTypeModal() {
            const modal = document.getElementById('customTypeModal');
            document.getElementById('customTypeName').value = '';
            document.getElementById('customTypeAttributes').value = '';
            
            // Reset color picker
            document.querySelectorAll('#customTypeColorPicker .color-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            document.querySelector('#customTypeColorPicker .color-option').classList.add('selected');
            
            modal.classList.add('active');
        }
        
        document.getElementById('cancelCustomTypeBtn').addEventListener('click', () => {
            document.getElementById('customTypeModal').classList.remove('active');
        });
        
        document.getElementById('createCustomTypeBtn').addEventListener('click', () => {
            const name = document.getElementById('customTypeName').value.trim();
            if (!name) {
                alert('Please enter a type name');
                return;
            }
            
            const id = name.toLowerCase().replace(/\s+/g, '_');
            
            // Check if already exists
            if (getAllNodeTypes().find(t => t.id === id)) {
                alert('A type with this name already exists');
                return;
            }
            
            const selectedColor = document.querySelector('#customTypeColorPicker .color-option.selected');
            const color = selectedColor ? selectedColor.style.backgroundColor : colors[0];
            
            const attrsInput = document.getElementById('customTypeAttributes').value.trim();
            const defaultAttributes = attrsInput ? attrsInput.split(',').map(a => a.trim()).filter(a => a) : [];
            
            const newType = {
                id: id,
                name: name,
                color: color,
                defaultAttributes: defaultAttributes,
                custom: true
            };
            
            state.customNodeTypes.push(newType);
            updateNodeTypeButtons();
            updateFilterOptions();
            broadcastState();
            saveToLocalStorage();
            
            document.getElementById('customTypeModal').classList.remove('active');
            
            if (document.getElementById('settingsModal').classList.contains('active')) {
                updateNodeTypesList();
            }
        });
        
        function updateNodeTypesList() {
            const list = document.getElementById('nodeTypesList');
            list.innerHTML = '';
            
            getAllNodeTypes().forEach(type => {
                const item = document.createElement('div');
                item.className = 'node-type-item';
                item.innerHTML = `
                    <div>
                        <span class="node-type-item-name">${type.name}</span>
                        ${type.custom ? ' <span style="font-size: 0.7rem; color: var(--text-secondary);">(custom)</span>' : ''}
                    </div>
                    <div class="node-type-item-actions">
                        <div style="width: 30px; height: 30px; background: ${type.color}; border-radius: 3px; border: 1px solid var(--border);"></div>
                        ${type.custom ? '<span class="node-type-item-delete">√ó</span>' : ''}
                    </div>
                `;
                
                if (type.custom) {
                    item.querySelector('.node-type-item-delete').addEventListener('click', () => {
                        if (confirm(`Delete custom type "${type.name}"? Existing nodes will keep their type.`)) {
                            state.customNodeTypes = state.customNodeTypes.filter(t => t.id !== type.id);
                            updateNodeTypeButtons();
                            updateFilterOptions();
                            updateNodeTypesList();
                            broadcastState();
                            saveToLocalStorage();
                        }
                    });
                }
                
                list.appendChild(item);
            });
        }
        
        // Templates
        function updateTemplateNodeSelect() {
            const select = document.getElementById('templateNodeSelect');
            select.innerHTML = '<option value="">Select a node...</option>';
            
            state.nodes.forEach(node => {
                const option = document.createElement('option');
                option.value = node.id;
                option.textContent = `${node.name} (${node.type})`;
                select.appendChild(option);
            });
        }
        
        document.getElementById('saveTemplateBtn').addEventListener('click', () => {
            const nodeId = document.getElementById('templateNodeSelect').value;
            if (!nodeId) {
                alert('Please select a node');
                return;
            }
            
            const node = state.nodes.find(n => n.id == nodeId);
            if (!node) return;
            
            const templateName = prompt('Template name:', node.name + ' Template');
            if (!templateName) return;
            
            const template = {
                id: Date.now(),
                name: templateName,
                type: node.type,
                description: node.description,
                color: node.color,
                tags: [...(node.tags || [])],
                attributes: {...(node.attributes || {})}
            };
            
            state.templates.push(template);
            updateTemplatesList();
            broadcastState();
            saveToLocalStorage();
        });
        
        function updateTemplatesList() {
            const list = document.getElementById('templatesList');
            list.innerHTML = '';
            
            if (state.templates.length === 0) {
                list.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.875rem;">No templates yet</p>';
                return;
            }
            
            state.templates.forEach(template => {
                const item = document.createElement('div');
                item.className = 'template-item';
                item.innerHTML = `
                    <div>
                        <div style="font-weight: 500;">${template.name}</div>
                        <div style="font-size: 0.75rem; color: var(--text-secondary);">${template.type}</div>
                    </div>
                    <div class="template-item-actions">
                        <button class="btn" data-action="use"><span>Use</span></button>
                        <button class="btn" data-action="delete"><span>Delete</span></button>
                    </div>
                `;
                
                item.querySelector('[data-action="use"]').addEventListener('click', () => {
                    const worldCenter = screenToWorld(canvas.width / 2, canvas.height / 2);
                    const node = {
                        id: Date.now() + Math.random(),
                        type: template.type,
                        name: template.name,
                        description: template.description,
                        color: template.color,
                        tags: [...template.tags],
                        attributes: {...template.attributes},
                        x: worldCenter.x,
                        y: worldCenter.y
                    };
                    
                    state.nodes.push(node);
                    updateNodesList();
                    updateListView();
                    updateFilterOptions();
                    render();
                    broadcastState();
                    
                    document.getElementById('settingsModal').classList.remove('active');
                });
                
                item.querySelector('[data-action="delete"]').addEventListener('click', () => {
                    if (confirm(`Delete template "${template.name}"?`)) {
                        state.templates = state.templates.filter(t => t.id !== template.id);
                        updateTemplatesList();
                        broadcastState();
                        saveToLocalStorage();
                    }
                });
                
                list.appendChild(item);
            });
        }
        
        document.getElementById('clearBtn').addEventListener('click', () => {
            if (confirm('Are you sure you want to clear everything?')) {
                state.nodes = [];
                state.links = [];
                state.selectedNode = null;
                state.linkingFrom = null;
                updateNodesList();
                updateListView();
                render();
                broadcastState();
            }
        });
        
        // ==================== COLLABORATION ====================
        
        // BroadcastChannel for real-time sync
        const channel = new BroadcastChannel('nexus-collab');
        
        function broadcastState() {
            const nexusName = document.getElementById('nexusName').value || 'Untitled World';
            const data = {
                type: 'state',
                id: state.myId,
                name: nexusName,
                nodes: state.nodes,
                links: state.links,
                customNodeTypes: state.customNodeTypes,
                templates: state.templates
            };
            
            // Broadcast locally (same browser)
            channel.postMessage(data);
            
            // Broadcast to peers (internet)
            broadcastStateToPeers();
            
            saveToLocalStorage();
        }
        
        function broadcastCursor(x, y) {
            channel.postMessage({
                type: 'cursor',
                id: state.myId,
                color: state.myColor,
                x: x,
                y: y
            });
            
            broadcastCursorToPeers(x, y);
        }
        
        channel.addEventListener('message', (event) => {
            const data = event.data;
            
            if (data.id === state.myId) return; // Ignore own messages
            
            if (data.type === 'state') {
                // Update from other user
                state.nodes = data.nodes;
                state.links = (data.links || []).map(link => ({
                    id: link.id || (Date.now() + Math.random()),
                    from: link.from,
                    to: link.to,
                    label: link.label || '',
                    description: link.description || ''
                }));
                state.customNodeTypes = data.customNodeTypes || [];
                state.templates = data.templates || [];
                document.getElementById('nexusName').value = data.name;
                updateNodesList();
                updateListView();
                updateFilterOptions();
                updateNodeTypeButtons();
                render();
                
                // Track collaborator
                if (!state.collaborators.has(data.id)) {
                    state.collaborators.set(data.id, {
                        id: data.id,
                        color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                        lastSeen: Date.now()
                    });
                    updateCollaboratorsList();
                }
            } else if (data.type === 'cursor') {
                // Update cursor
                updateCollaboratorCursor(data.id, data.color, data.x, data.y);
                
                if (!state.collaborators.has(data.id)) {
                    state.collaborators.set(data.id, {
                        id: data.id,
                        color: data.color,
                        lastSeen: Date.now()
                    });
                    updateCollaboratorsList();
                }
            }
        });
        
        // Cursor rendering
        function updateCollaboratorCursor(id, color, x, y) {
            let cursor = document.getElementById(`cursor-${id}`);
            if (!cursor) {
                cursor = document.createElement('div');
                cursor.id = `cursor-${id}`;
                cursor.className = 'collab-cursor';
                cursor.innerHTML = `
                    <svg width="24" height="24" viewBox="0 0 24 24">
                        <path d="M5 3 L19 12 L12 13 L9 19 Z" fill="${color}" stroke="white" stroke-width="1"/>
                    </svg>
                    <div class="collab-cursor-name" style="color: ${color};">User ${id.substring(0, 4)}</div>
                `;
                document.getElementById('canvasContainer').appendChild(cursor);
            }
            cursor.style.left = x + 'px';
            cursor.style.top = y + 'px';
            
            // Update last seen
            const collab = state.collaborators.get(id);
            if (collab) {
                collab.lastSeen = Date.now();
            }
        }
        
        // Clean up old collaborators
        setInterval(() => {
            const now = Date.now();
            state.collaborators.forEach((collab, id) => {
                if (now - collab.lastSeen > 5000) {
                    state.collaborators.delete(id);
                    const cursor = document.getElementById(`cursor-${id}`);
                    if (cursor) cursor.remove();
                    updateCollaboratorsList();
                }
            });
        }, 2000);
        
        // Share panel
        document.getElementById('shareBtn').addEventListener('click', () => {
            const panel = document.getElementById('sharePanel');
            panel.classList.add('active');
            
            // Generate shareable URL with room code
            let url;
            if (state.roomCode) {
                url = window.location.origin + window.location.pathname + '?room=' + state.roomCode;
            } else {
                // Fallback to old hash-based sharing
                const nexusName = document.getElementById('nexusName').value || 'Untitled World';
                const data = {
                    name: nexusName,
                    nodes: state.nodes,
                    links: state.links,
                    customNodeTypes: state.customNodeTypes,
                    templates: state.templates
                };
                const encoded = btoa(encodeURIComponent(JSON.stringify(data)));
                url = window.location.origin + window.location.pathname + '#' + encoded;
            }
            
            document.getElementById('shareUrl').textContent = url;
            updateCollaboratorsList();
        });
        
        document.getElementById('closeShareBtn').addEventListener('click', () => {
            document.getElementById('sharePanel').classList.remove('active');
        });
        
        document.getElementById('copyUrlBtn').addEventListener('click', () => {
            const url = document.getElementById('shareUrl').textContent;
            navigator.clipboard.writeText(url).then(() => {
                const btn = document.getElementById('copyUrlBtn');
                const originalText = btn.innerHTML;
                btn.innerHTML = '<span>Copied!</span>';
                setTimeout(() => {
                    btn.innerHTML = originalText;
                }, 2000);
            });
        });
        
        function updateCollaboratorsList() {
            const list = document.getElementById('collaboratorsList');
            list.innerHTML = '';
            
            // Add self
            const selfItem = document.createElement('div');
            selfItem.className = 'collaborator-item';
            selfItem.innerHTML = `
                <div class="collaborator-dot" style="background: ${state.myColor};"></div>
                <span>You ${state.isHost ? '(Host)' : ''}</span>
            `;
            list.appendChild(selfItem);
            
            // Add local collaborators (same browser)
            state.collaborators.forEach((collab, id) => {
                const item = document.createElement('div');
                item.className = 'collaborator-item';
                item.innerHTML = `
                    <div class="collaborator-dot" style="background: ${collab.color};"></div>
                    <span>User ${id.substring(0, 6)} (local)</span>
                `;
                list.appendChild(item);
            });
            
            // Add peer collaborators (internet)
            state.connections.forEach((conn, peerId) => {
                const item = document.createElement('div');
                item.className = 'collaborator-item';
                const color = `hsl(${Math.abs(peerId.split('').reduce((a,b) => a + b.charCodeAt(0), 0)) % 360}, 70%, 60%)`;
                item.innerHTML = `
                    <div class="collaborator-dot" style="background: ${color};"></div>
                    <span>Peer ${peerId.substring(6, 12)}</span>
                `;
                list.appendChild(item);
            });
            
            if (state.collaborators.size === 0 && state.connections.size === 0) {
                const emptyMsg = document.createElement('div');
                emptyMsg.style.color = 'var(--text-tertiary)';
                emptyMsg.style.padding = '0.5rem';
                emptyMsg.style.fontSize = '0.85rem';
                emptyMsg.textContent = 'No other collaborators yet';
                list.appendChild(emptyMsg);
            }
        }
        
        // ==================== LOCAL STORAGE ====================
        
        function saveToLocalStorage() {
            const nexusName = document.getElementById('nexusName').value || 'Untitled World';
            const data = {
                name: nexusName,
                nodes: state.nodes,
                links: state.links,
                camera: state.camera,
                customNodeTypes: state.customNodeTypes,
                templates: state.templates
            };
            localStorage.setItem('nexus-autosave', JSON.stringify(data));
        }
        
        function loadFromLocalStorage() {
            const saved = localStorage.getItem('nexus-autosave');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    document.getElementById('nexusName').value = data.name || 'Untitled World';
                    state.nodes = data.nodes || [];
                    state.links = (data.links || []).map(link => ({
                        id: link.id || (Date.now() + Math.random()),
                        from: link.from,
                        to: link.to,
                        label: link.label || '',
                        description: link.description || ''
                    }));
                    state.customNodeTypes = data.customNodeTypes || [];
                    state.templates = data.templates || [];
                    if (data.camera) {
                        state.camera = data.camera;
                    }
                    updateNodesList();
                    updateListView();
                    updateFilterOptions();
                    updateNodeTypeButtons();
                    render();
                } catch (err) {
                    console.error('Error loading autosave:', err);
                }
            }
        }
        
        // ==================== URL SHARING ====================
        
        function loadFromURL() {
            const hash = window.location.hash.substring(1);
            if (hash) {
                try {
                    const decoded = JSON.parse(decodeURIComponent(atob(hash)));
                    document.getElementById('nexusName').value = decoded.name || 'Untitled World';
                    state.nodes = decoded.nodes || [];
                    state.links = (decoded.links || []).map(link => ({
                        id: link.id || (Date.now() + Math.random()),
                        from: link.from,
                        to: link.to,
                        label: link.label || '',
                        description: link.description || ''
                    }));
                    state.customNodeTypes = decoded.customNodeTypes || [];
                    state.templates = decoded.templates || [];
                    updateNodesList();
                    updateListView();
                    updateFilterOptions();
                    updateNodeTypeButtons();
                    render();
                    broadcastState();
                } catch (err) {
                    console.error('Error loading from URL:', err);
                }
            }
        }
        
        // ==================== INITIALIZATION ====================
        
        window.addEventListener('load', () => {
            const loading = document.getElementById('loading');
            loading.classList.add('active');
            
            setTimeout(() => {
                // Load from URL first, then from localStorage if no URL
                if (window.location.hash) {
                    loadFromURL();
                } else {
                    loadFromLocalStorage();
                }
                
                // Initialize UI
                updateNodeTypeButtons();
                updateFilterOptions();
                
                // Initialize PeerJS networking
                initializePeer();
                
                loading.classList.remove('active');
                
                // Initial render
                render();
                
                // Announce presence
                broadcastState();
            }, 1000);
        });
        
        // Auto-save every 10 seconds
        setInterval(() => {
            if (state.nodes.length > 0) {
                saveToLocalStorage();
            }
        }, 10000);
        
        // Update nexus name
        document.getElementById('nexusName').addEventListener('input', () => {
            broadcastState();
        });
    </script>
</body>

</html>

